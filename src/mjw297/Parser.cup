package mjw297;

import java_cup.runtime.*;
import java.util.ArrayList;
import mjw297.Ast.*;

////////////////////////////////////////////////////////////////////////////////
// Terminals
////////////////////////////////////////////////////////////////////////////////
// Symbols
terminal MINUS,      // -
         BANG,       // !
         STAR,       // *
         HIGHMULT,   // *>>
         DIV,        // /
         MOD,        // %
         PLUS,       // +
         EQ,         // =
         LT,         // <
         LTE,        // <=
         GTE,        // >=
         GT,         // >
         EQEQ,       // ==
         NEQ,        // !=
         AMP,        // &
         BAR,        // |
         SEMICOLON,  // ;
         LPAREN,     // (
         RPAREN,     // )
         LBRACKET,   // [
         RBRACKET,   // ]
         LBRACE,     // {
         RBRACE,     // }
         UNDERSCORE, // _
         COMMA,      // ,
         COLON,      // :
		 UMINUS;	 // -

// Keywords
terminal WHILE,  // while
         IF,     // if
         ELSE,   // else
         RETURN, // return
         INT,    // int
         BOOL,   // bool
         USE,    // use
         LENGTH, // length
         TRUE,   // true
         FALSE;  // false

// Valued Terminals
terminal String    STRING;  // "foo", "bar", ...,
terminal Character CHAR;    // 'a', 'b', ...
terminal String    ID;      // foo, foo_bar, t'is_2_cold_4_me

// Lexing integer literals is trickier than it seems. The Xi language
// specification says that integer literals can range from -9223372036854775808
// (-2^63) to 9223372036854775807 (2^63 - 1). Imagine we try to lex the string
// "-9223372036854775808". What should our lexer do?
//
//   (1) We could lex the string as two tokens: a MINUS token, and
//       a NUM token. The catch is that 9223372036854775808 doesn't fit inside
//       of a Java long, so we can't stick 9223372036854775808 in a NUM token!
//   (2) We could have a regular expression, "-9223372036854775808", that lexes
//       the string as a single NUM token with the value -9223372036854775808.
//       But then, our lexer wouldn't lex "-9223372036854775808"!
//   (3) We could beef up our regular expression from attempt (2) and disregard
//       whitespace between the "-" and the "9223372036854775808". For example,
//       our regular expression could be `- {Whitespace}* 9223372036854775808`.
//       This is also insufficient. Consider the following Xi snippet:
//
//           x: int = -
//                    // random comment
//                    9223372036854775808
//
//       Our regular expression wouldn't lex this correctly.
//   (4) We could beef up our regular expression again accounting for any
//       possible tokens that could occur between '-' and
//       '9223372036854775808'!  Right now that only includes whitespace and
//       single line comments.
//   (5) We could introduce a new token BIG_NUM that is created whenever we lex
//       9223372036854775808 and defer responsibility to the parser.
//
// Solutions (1) - (3) are insufficient. Solutions (4) and (5) have their
// tradeoffs. It's not clear whether (4) is even correct, but (5) complicates
// things quite a bit. We have opted for option (5) because it seems the
// hardest to get wrong.
terminal Long NUM;     // -9223372036854775808, ..., 0, ..., 9223372036854775807
terminal      BIG_NUM; // 9223372036854775808

////////////////////////////////////////////////////////////////////////////////
// Nonterminals
////////////////////////////////////////////////////////////////////////////////

// types and variables
nonterminal Type
    base_type,
    type;

nonterminal AnnotatedVar
    avar;

nonterminal Var
    var;

// statements
nonterminal
    end_stmt;

nonterminal Stmt
    full_stmt,
    stmt,
    block,
    full_decl,
    decl,
    asgn,
    if_body,
    if_stmt,
    while_body,
    while_stmt,
    call;

nonterminal List<Expr>
    args_call;

// functions and procedures
nonterminal List<Expr>
    args_decl,
    func_ret;

nonterminal
    proc_ret;

nonterminal Callable
    proc_decl,
    func_decl;

// programs
nonterminal Use
    use_def;

nonterminal Callable
    func_def;

nonterminal List<Use>
    use_def_star;

nonterminal List<Callable>
    func_def_plus;

nonterminal Program
    prog;

// expressions
nonterminal Expr
    expr,
    literal,
    binop,
    unop;

nonterminal List<Expr>
    empty_array_index_star,
    num_array_index_plus,
    array_index_plus;

// various lists
nonterminal List<Expr>
    expr_star,
    expr_plus;

nonterminal List<AnnotatedVar>
    avar_plus;

nonterminal List<Var>
    var_plus;

nonterminal List<Type>
    type_plus;

nonterminal List<Stmt>
    stmt_star;

////////////////////////////////////////////////////////////////////////////////
// Precedence
////////////////////////////////////////////////////////////////////////////////

precedence nonassoc ID;
precedence nonassoc ELSE;
precedence nonassoc SEMICOLON;
precedence nonassoc EQ;

precedence left BAR;
precedence left AMP;
precedence left EQEQ, NEQ;
precedence left GT, GTE, LT, LTE;
precedence left PLUS, MINUS;
precedence left STAR, DIV, MOD, HIGHMULT;
precedence nonassoc BANG, UMINUS;
precedence left LBRACKET, RBRACKET;

////////////////////////////////////////////////////////////////////////////////
// Grammar
////////////////////////////////////////////////////////////////////////////////

start with prog;

// Types and variables --SH

base_type ::= INT 
	{: RESULT = new Ast.Int(); :}
    | BOOL
	{: RESULT = new Ast.Bool(); :}
    ;

type ::= base_type:bt
	{: RESULT = bt; :}
    | type:t LBRACKET RBRACKET
	{: RESULT = new Ast.Array(t); :}
    ;

avar ::= ID:id COLON type:t
	{: RESULT = new AnnotatedId(new Id(id), t); :}
    | UNDERSCORE COLON type:t
	{: RESULT = new AnnotatedUnderscore(new Underscore(), t); :}
    ;

var ::= avar:av
	{: RESULT = av; :}
    | UNDERSCORE
	{: RESULT = new Underscore(); :}
    | ID:id COLON base_type:bt array_index_plus:e_lst
	{: if (e_lst != null) {
	       RESULT = new AnnotatedId(new Id(id), new Array(bt, e_lst));
	   } else {
		   RESULT = new AnnotatedId(new Id(id), new Array(bt));
	   }
    :}
    ;


// Statements --RR

stmt ::= full_decl:f                                             
	{: RESULT = f; :}
    | asgn:a                                                     
	{: RESULT = a; :}
    | if_stmt:i                                                 
	{: RESULT = i; :}
    | while_stmt:w                                               
	{: RESULT = w; :}
    | call:c                                                     
	{: RESULT = c; :}
    ;

end_stmt ::=
    | SEMICOLON
    ;

full_stmt ::= stmt:s end_stmt                                   
	{: RESULT = s; :};

block ::= LBRACE stmt_star:s RBRACE
	{: RESULT = s; :};

full_decl ::= decl:d                                             
	{: RESULT = d; :}
    | decl:d EQ expr:e
	{: RESULT = new DeclAsgn(d.vs, e); :}
    ;

decl ::= var_plus:v
	{: RESULT = new Ast.Decl(v); :}
    ;

asgn ::= ID:i EQ expr:e
	{: RESULT = new Ast.Asgn(i, e); :}
    | ID:i num_array_index_plus:b EQ expr:e
	{: RESULT = new Ast.AsgnArrayIndex(i, b, e); :}
    ;

if_body ::= block:b                                              
	{: RESULT = b; :}
   	| full_stmt:s                                                 
	{: RESULT = s; :}
   	;

if_stmt ::= IF LPAREN expr:e RPAREN if_body:s1 ELSE if_body:s2            
	{: RESULT = new Ast.IfElse(e, s1, s2); :}
   	| IF LPAREN expr:e RPAREN if_body:s                           
	{: RESULT = new Ast.If(e, s); :}
   	;

while_body ::= block:b                                           
	{: RESULT = b; :}
  	| full_stmt:s                                                  
	{: RESULT = s; :}
  	;

while_stmt ::= WHILE LPAREN expr:e RPAREN while_body:b
	{: RESULT = new Ast.While(e, b); :}
	;

args_call ::= LPAREN RPAREN                                      
	{: RESULT = new ArrayList<>(); :}
    | LPAREN expr_plus:e RPAREN                                  
	{: RESULT = e; :}
    ;

call ::= ID:i args_call:a
	{: RESULT = new Ast.Call(i, a); :}
	;


// Functions and procedures --AM

args_decl ::= LPAREN RPAREN
    {: RESULT = new ArrayList<Expr>(); :}
    | LPAREN avar_plus:a RPAREN
    {: RESULT = a; :}
    ;

proc_ret ::=
    {: RESULT = null; :}
    | RETURN end_stmt
    {: RESULT = null; :}
    ;

func_ret ::= RETURN expr_plus:e end_stmt
    {: RESULT = e; :};

proc_decl ::= ID:p args_decl:a LBRACE stmt_star:s proc_ret RBRACE
    {: RESULT = new Proc(new Id(p), a, s); :};

func_decl ::= ID:f args_decl:a COLON type_plus:t LBRACE stmt_star:s func_ret:r RBRACE
    {: RESULT = new Func(new Id(f), a, t, s, r); :}
    ;


// Programs --AM

use_def ::= USE ID:x end_stmt
    {: RESULT = new Use(new Id(x)); :};

func_def ::= func_decl:f
    {: RESULT = f; :}
    | proc_decl:p
    {: RESULT = p; :}
    ;

use_def_star ::=
    {: RESULT = new ArrayList<Use>(); :}
    | use_def_star:us use_def:u
    {: RESULT = us.add(u); :}
    ;

func_def_plus ::= func_def:f
    {: RESULT = (new ArrayList<Callable>()).add(f); :}
    | func_def_plus:fs func_def:f
    {: RESULT = fs.add(f); :}
    ;

prog ::= use_def_star:us func_def_plus:fs
    {: RESULT = new Program(us, fs); :};


// Expressions --SH

expr ::= literal:l
	{: RESULT = l; :}
    | expr:e1 binop:op expr:e2
	{: RESULT = new BinOp(op, e1, e2); :} 
    | unop:op expr:e
	{: RESULT = new UnOp(op, e); :} %prec UMINUS
    | expr:e1 num_array_index_plus:e_lst
	{: RESULT = new Index(e1, e_lst); :}
    | LENGTH LPAREN expr:e RPAREN
	{: RESULT = new Length(e); :}
    | LPAREN expr:e RPAREN
	{: RESULT = new ParenthesizedExpr(e); :}
    | call:c
	{: RESULT = c; :}
    | ID:id
	{: RESULT = new Id(id); :}
    ;

empty_array_index_star ::=
	{: RESULT = null; :}
    | empty_array_index_star LBRACKET RBRACKET
	{: RESULT = null; :}
    ;

// TODO: expr or NUM?
num_array_index_plus ::= LBRACKET expr:e RBRACKET
	{: ArrayList<Expr> list = new ArrayList<Expr>();
	   list.add(e);
	   RESULT = list; :}
    | num_array_index_plus:e_lst LBRACKET expr:e RBRACKET
	{: e_lst.add(e);
	   RESULT = e_lst; :}
    ;

array_index_plus ::= LBRACKET RBRACKET empty_array_index_star
	{: RESULT = null; :}
    | num_array_index_plus:e_lst empty_array_index_star
	{: RESULT = e_lst; :}
    ;

literal ::= NUM:n 
	{: RESULT = new NumLiteral(n); :}
    | MINUS BIG_NUM:n // TODO : ok?
	{: RESULT = new NumLiteral(-n); :}
    | STRING:s
	{: RESULT = new StringLiteral(s); :}
    | CHAR:c
	{: RESULT = new CharLiteral(c); :}
    | TRUE:b
	{: RESULT = new BoolLiteral(b); :}	
    | FALSE:b
	{: RESULT = new BoolLiteral(b); :}
    | LBRACE expr_star:e RBRACE
	{: RESULT = new ArrayLiteral(e); :}
    | LBRACE expr_plus:e COMMA RBRACE
	{: RESULT = new ArrayLiteral(e); :}
    ;

binop ::= MINUS
	{: RESULT = BinOpCode.MINUS; :}
    | STAR
	{: RESULT = BinOpCode.STAR; :}
    | HIGHMULT
	{: RESULT = BinOpCode.HIGHMULT; :}
    | DIV
	{: RESULT = BinOpCode.DIV; :}
    | MOD
	{: RESULT = BinOpCode.MOD; :}
    | PLUS
	{: RESULT = BinOpCode.PLUS; :}
    | LT
	{: RESULT = BinOpCode.LT; :}
    | LTE
	{: RESULT = BinOpCode.LTE; :}
    | GTE
	{: RESULT = BinOpCode.GTE; :}
    | GT
	{: RESULT = BinOpCode.GT; :}
    | EQEQ
	{: RESULT = BinOpCode.EQEQ; :}
    | NEQ
	{: RESULT = BinOpCode.NEQ; :}
    | AMP
	{: RESULT = BinOpCode.AMP; :}
    | BAR
	{: RESULT = BinOpCode.BAR; :}
    ;

unop ::= BANG
	{: RESULT = UnOpCode.BANG; :}
    | MINUS
	{: RESULT = UnOpCode.UMINUS; :}
    ;


// Various lists --SH

expr_star ::=
	{: RESULT = new ArrayList<Expr>(); :}
    | expr_plus:e_lst
	{: RESULT = e_lst; :}
    ;

expr_plus ::= expr:e
	{: ArrayList<Expr> list = new ArrayList<Expr>();
	   list.add(e);
	   RESULT = list; :}
    | expr_plus:e_lst COMMA expr:e
	{: RESULT = e_list.add(e); :}
    ;

avar_plus ::= avar:av
	{: ArrayList<AnnotatedVar> list = new ArrayList<AnnotatedVar>();
	   list.add(av);
	   RESULT = list; :}
    | avar_plus:a_lst COMMA avar:av
	{: a_lst.add(av); 
	   RESULT = a_lst; :}
    ;

var_plus ::= var:v
	{: ArrayList<Var> list = new ArrayList<Var>();
	   list.add(v);
	   RESULT = list; :}
    | var_plus:v_lst COMMA var:v
	{: v_lst.add(v);
	   RESULT = v_lst; :}
    ;

type_plus ::= type:t
	{: ArrayList<Type> list = new ArrayList<Type>();
	   list.add(t);
	   RESULT = list; :}
    | type_plus:t_lst COMMA type:t
	{: t_lst.add(t);
	   RESULT = t_lst; :}
    ;

stmt_star ::=
	{: RESULT = new ArrayList<Stmt>(); :}
    | stmt_star:s_lst full_stmt:s
	{: s_lst.add(s);
	   RESULT = s_lst; :}
    ;
