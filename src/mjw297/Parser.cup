import java_cup.runtime.*;

////////////////////////////////////////////////////////////////////////////////
// Terminals
////////////////////////////////////////////////////////////////////////////////
// Symbols
terminal MINUS,      // -
         BANG,       // !
         STAR,       // *
         HIGHMULT,   // *>>
         DIV,        // /
         MOD,        // %
         PLUS,       // +
         EQ,         // =
         LT,         // <
         LTE,        // <=
         GTE,        // >=
         GT,         // >
         EQEQ,       // ==
         NEQ,        // !=
         AMP,        // &
         BAR,        // |
         SEMICOLON,  // ;
         LPAREN,     // (
         RPAREN,     // )
         LBRACKET,   // [
         RBRACKET,   // ]
         LBRACE,     // {
         RBRACE,     // }
         UNDERSCORE, // _
         COMMA,      // ,
         COLON,      // :
		 UMINUS;	 // -

// Keywords
terminal WHILE,  // while
         IF,     // if
         ELSE,   // else
         RETURN, // return
         INT,    // int
         BOOL,   // bool
         USE,    // use
         LENGTH, // length
         TRUE,   // true
         FALSE;  // false

// Valued Terminals
terminal String    STRING;  // "foo", "bar", ...,
terminal Character CHAR;    // 'a', 'b', ...
terminal String    ID;      // foo, foo_bar, t'is_2_cold_4_me

// Lexing integer literals is trickier than it seems. The Xi language
// specification says that integer literals can range from -9223372036854775808
// (-2^63) to 9223372036854775807 (2^63 - 1). Imagine we try to lex the string
// "-9223372036854775808". What should our lexer do?
//
//   (1) We could lex the string as two tokens: a MINUS token, and
//       a NUM token. The catch is that 9223372036854775808 doesn't fit inside
//       of a Java long, so we can't stick 9223372036854775808 in a NUM token!
//   (2) We could have a regular expression, "-9223372036854775808", that lexes
//       the string as a single NUM token with the value -9223372036854775808.
//       But then, our lexer wouldn't lex "-9223372036854775808"!
//   (3) We could beef up our regular expression from attempt (2) and disregard
//       whitespace between the "-" and the "9223372036854775808". For example,
//       our regular expression could be `- {Whitespace}* 9223372036854775808`.
//       This is also insufficient. Consider the following Xi snippet:
//
//           x: int = -
//                    // random comment
//                    9223372036854775808
//
//       Our regular expression wouldn't lex this correctly.
//   (4) We could beef up our regular expression again accounting for any
//       possible tokens that could occur between '-' and
//       '9223372036854775808'!  Right now that only includes whitespace and
//       single line comments.
//   (5) We could introduce a new token BIG_NUM that is created whenever we lex
//       9223372036854775808 and defer responsibility to the parser.
//
// Solutions (1) - (3) are insufficient. Solutions (4) and (5) have their
// tradeoffs. It's not clear whether (4) is even correct, but (5) complicates
// things quite a bit. We have opted for option (5) because it seems the
// hardest to get wrong.
terminal Long NUM;     // -9223372036854775808, ..., 0, ..., 9223372036854775807
terminal      BIG_NUM; // 9223372036854775808

////////////////////////////////////////////////////////////////////////////////
// Nonterminals
////////////////////////////////////////////////////////////////////////////////

// types and variables
nonterminal base_type,
            type,
            type_list,
            avar,
            var;

// statements
nonterminal end_stmt,
            full_stmt,
            stmt,
            block,
            full_decl,
            decl,
            asgn,
            if_body,
            if_stmt,
            while_body,
            while_stmt,
            args_call,
            call;

// functions and procedures
nonterminal args_decl,
            proc_ret,
            func_ret,
            proc_decl,
            func_decl;

// programs
nonterminal use_def,
            func_def,
            use_def_star,
			func_def_plus,
			prog;

// expressions
nonterminal expr,
            array_body,
            array,
            empty_array_index_star,
            num_array_index_plus,
            array_index_plus,
            literal,
            binop,
            unop;

// various lists
nonterminal expr_star,
			expr_plus,
			avar_plus,
			var_plus,
			type_plus,
			stmt_star,
            extended_expr,
            paren_expr;

////////////////////////////////////////////////////////////////////////////////
// Precedence
////////////////////////////////////////////////////////////////////////////////

precedence nonassoc ID;
precedence nonassoc ELSE;
precedence nonassoc SEMICOLON;
precedence nonassoc EQ;

precedence left BAR;
precedence left AMP;
precedence left EQEQ, NEQ;
precedence left GT, GTE, LT, LTE;
precedence left PLUS, MINUS;
precedence left STAR, DIV, MOD, HIGHMULT;
precedence nonassoc BANG, UMINUS;
precedence left LBRACKET, RBRACKET;

////////////////////////////////////////////////////////////////////////////////
// Grammar
////////////////////////////////////////////////////////////////////////////////

start with prog;

// Types and variables --SH

base_type ::= INT 
	{: RESULT = new Int(); :}
    | BOOL
	{: RESULT = new Bool(); :}
    ;

type ::= base_type:bt
	{: RESULT = bt; :}
    | type:t LBRACKET RBRACKET
	{: RESULT = new Array(t); :}
    ;

avar ::= ID:id COLON type:t
	{: RESULT = new AnnotatedId(new Id(id), t); :}
    | UNDERSCORE COLON type
	{: RESULT = new AnnotatedUnderscore(new Underscore(), t); :}
    ;

var ::= avar:av
	{: RESULT = av; :}
    | UNDERSCORE
	{: RESULT = new Underscore(); :}
    | ID:id COLON base_type:bt array_index_plus:e_lst
	{: if (e_lst != null) {
	       RESULT = new AnnotatedId(new Id(id), new Array(bt, e_lst));
	   } else {
		   RESULT = new AnnotatedId(new Id(id), new Array(bt));
	   } :}
    ;


// Statements --RR

stmt ::= full_decl
    | asgn
    | if_stmt
    | while_stmt
    | call
    ;

end_stmt ::=
    | SEMICOLON
    ;

full_stmt ::= stmt end_stmt;

block ::= LBRACE stmt_star RBRACE;

full_decl ::= decl
    | decl EQ extended_expr
    ;

decl ::= var
    | LPAREN var_plus RPAREN
    ;

asgn ::= ID EQ extended_expr
    | ID num_array_index_plus EQ extended_expr
    ;

if_body ::= block
   | full_stmt
   ;

if_stmt ::= IF LPAREN expr RPAREN if_body ELSE if_body
   | IF LPAREN expr RPAREN if_body
   ;

while_body ::= block
  | full_stmt
  ;

while_stmt ::= WHILE LPAREN expr RPAREN while_body;

args_call ::= LPAREN RPAREN
    | LPAREN expr_plus RPAREN
    ;

call ::= ID args_call;


// Functions and procedures --AM

args_decl ::= LPAREN RPAREN
    | LPAREN avar_plus RPAREN
    ;

proc_ret ::=
    | RETURN end_stmt
    ;

func_ret ::= RETURN LPAREN expr_plus RPAREN end_stmt;

proc_decl ::= ID args_decl LBRACE stmt_star proc_ret RBRACE;

func_decl ::= ID args_decl COLON type LBRACE stmt_star func_ret RBRACE
    | ID args_decl COLON LPAREN type_plus RPAREN LBRACE stmt_star func_ret RBRACE
    ;


// Programs --AM

use_def ::= USE ID end_stmt;

func_def ::= func_decl
    | proc_decl
    ;

use_def_star ::=
    | use_def_star use_def
    ;

func_def_plus ::= func_def
    | func_def_plus func_def
    ;

prog ::= use_def_star func_def_plus;


// Expressions --SH

expr ::= literal:l
	{: RESULT = l; :}
    | expr:e1 binop:op expr:e2
	{: RESULT = new BinOp(op, e1, e2); :} 
    | unop:op expr:e
	{: RESULT = new UnOp(op, e); :} %prec UMINUS
    | expr:e1 num_array_index_plus:e_lst
	{: RESULT = new Index(e1, e_lst); :}
    | LENGTH LPAREN expr:e RPAREN
	{: RESULT = new Length(e); :}
    | LPAREN expr:e RPAREN
	{: RESULT = new ParenthesizedExpr(e); :}
    | call:c
	{: RESULT = c; :}
    | ID:id
	{: RESULT = new Id(id); :}
    ;

extended_expr ::= paren_expr:e
	{: RESULT = e; :}
    | array:a
	{: RESULT = a; :}
    | extended_expr:e1 binop:op extended_expr:e2
	{: RESULT = new BinOp(op, e1, e2); :}
    ;

paren_expr ::= literal:l
	{: RESULT = l; :}
    | paren_expr:e1 binop:op paren_expr:e2
	{: RESULT = new BinOp(op, e1, e2); :}
    | unop:op paren_expr:e
	{: RESULT = new UnOp(op, e); :} %prec UMINUS
    | paren_expr:e1 num_array_index_plus:e_lst
	{: RESULT = new Index(e1, e_lst); :}
    | LENGTH LPAREN paren_expr:e RPAREN
	{: RESULT = new Length(e); :}
    | LPAREN paren_expr:e RPAREN
	{: RESULT = new ParenthesizedExpr(e); :}
    | call:c
	{: RESULT = c; :}
    | ID:id
	{: RESULT = new Id(id); :}
    ;

array_body ::= paren_expr:e1 COMMA paren_expr:e2
	{: ArrayList<Expr> list = new ArrayList();
	   list.add(e1);
	   list.add(e2);
	   RESULT = list; :}  
    | array:a
	{: ArrayList<Expr> list = new ArrayList();
	   RESULT = list.add(a); :}
    | array_body:ab COMMA paren_expr:e
	{: RESULT = ab.add(e); :}
    | array_body:ab COMMA array:a
	{: RESULT = ab.add(a); :}
    ;

array ::= LPAREN paren_expr:e COMMA RPAREN
	{: ArrayList<Expr> list = new ArrayList();
	   list.add(e);
	   RESULT = new ArrayLiteral(list); :}
    | LPAREN array_body:ab RPAREN
	{: RESULT = new ArrayLiteral(ab); :}
    | LPAREN array_body:ab COMMA RPAREN
	{: RESULT = new ArrayLiteral(ab); :}
    ;

empty_array_index_star ::=
	{: RESULT = null; :}
    | empty_array_index_star LBRACKET RBRACKET
	{: RESULT = null; :}
    ;

// TODO: expr or NUM?
num_array_index_plus ::= LBRACKET expr:e RBRACKET
	{: ArrayList<Expr> list = new ArrayList<Expr>();
	   list.add(e);
	   RESULT = list; :}
    | num_array_index_plus:e_lst LBRACKET expr:e RBRACKET
	{: e_lst.add(e);
	   RESULT = e_lst; :}
    ;

array_index_plus ::= LBRACKET RBRACKET empty_array_index_star
	{: RESULT = null; :}
    | num_array_index_plus:e_lst empty_array_index_star
	{: RESULT = e_lst; :}
    ;

literal ::= NUM:n 
	{: RESULT = new NumLiteral(n); :}
    | MINUS BIG_NUM:n // TODO : ok?
	{: RESULT = new NumLiteral(-n); :}
    | STRING:s
	{: RESULT = new StringLiteral(s); :}
    | CHAR:c
	{: RESULT = new CharLiteral(c); :}
    | TRUE:b
	{: RESULT = new BoolLiteral(b); :}	
    | FALSE:b
	{: RESULT = new BoolLiteral(b); :}
    ;

binop ::= MINUS
	{: RESULT = BinOpCode.MINUS; :}
    | STAR
	{: RESULT = BinOpCode.STAR; :}
    | HIGHMULT
	{: RESULT = BinOpCode.HIGHMULT; :}
    | DIV
	{: RESULT = BinOpCode.DIV; :}
    | MOD
	{: RESULT = BinOpCode.MOD; :}
    | PLUS
	{: RESULT = BinOpCode.PLUS; :}
    | LT
	{: RESULT = BinOpCode.LT; :}
    | LTE
	{: RESULT = BinOpCode.LTE; :}
    | GTE
	{: RESULT = BinOpCode.GTE; :}
    | GT
	{: RESULT = BinOpCode.GT; :}
    | EQEQ
	{: RESULT = BinOpCode.EQEQ; :}
    | NEQ
	{: RESULT = BinOpCode.NEQ; :}
    | AMP
	{: RESULT = BinOpCode.AMP; :}
    | BAR
	{: RESULT = BinOpCode.BAR; :}
    ;

unop ::= BANG
	{: RESULT = UnOpCode.BANG; :}
    | MINUS
	{: RESULT = UnOpCode.UMINUS; :}
    ;


// Various lists --SH

expr_star ::=
	{: RESULT = new ArrayList<Expr>(); :}
    | expr_plus:e_lst
	{: RESULT = e_lst; :}
    ;

expr_plus ::= expr:e
	{: ArrayList<Expr> list = new ArrayList<Expr>();
	   list.add(e);
	   RESULT = list; :}
    | expr_plus:e_lst COMMA expr:e
	{: RESULT = e_list.add(e); :}
    ;

avar_plus ::= avar:av
	{: ArrayList<AnnotatedVar> list = new ArrayList<AnnotatedVar>();
	   list.add(av);
	   RESULT = list; :}
    | avar_plus:a_lst COMMA avar:av
	{: a_lst.add(av); 
	   RESULT = a_lst; :}
    ;

var_plus ::= var:v
	{: ArrayList<Var> list = new ArrayList<Var>();
	   list.add(v);
	   RESULT = list; :}
    | var_plus:v_lst COMMA var:v
	{: v_lst.add(v);
	   RESULT = v_lst; :}
    ;

type_plus ::= type:t
	{: ArrayList<Type> list = new ArrayList<Type>();
	   list.add(t);
	   RESULT = list; :}
    | type_plus:t_lst COMMA type:t
	{: t_lst.add(t);
	   RESULT = t_lst; :}
    ;

stmt_star ::=
	{: RESULT = new ArrayList<Stmt>(); :}
    | stmt_star:s_lst full_stmt:s
	{: s_lst.add(s);
	   RESULT = s_lst; :}
    ;
