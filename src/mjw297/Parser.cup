import java_cup.runtime.*;

////////////////////////////////////////////////////////////////////////////////
// Terminals
////////////////////////////////////////////////////////////////////////////////
// Symbols
terminal MINUS,      // -
         BANG,       // !
         STAR,       // *
         HIGHMULT,   // *>>
         DIV,        // /
         MOD,        // %
         PLUS,       // +
         EQ,         // =
         LT,         // <
         LTE,        // <=
         GTE,        // >=
         GT,         // >
         EQEQ,       // ==
         NEQ,        // !=
         AMP,        // &
         BAR,        // |
         SEMICOLON,  // ;
         LPAREN,     // (
         RPAREN,     // )
         LBRACKET,   // [
         RBRACKET,   // ]
         LBRACE,     // {
         RBRACE,     // }
         UNDERSCORE, // _
         COMMA,      // ,
         COLON;      // :

// Keywords
terminal WHILE,  // while
         IF,     // if
         ELSE,   // else
         RETURN, // return
         INT,    // int
         BOOL,   // bool
         USE,    // use
         LENGTH, // length
         TRUE,   // true
         FALSE;  // false

// Valued Terminals
terminal String    STRING;  // "foo", "bar", ...,
terminal Character CHAR;    // 'a', 'b', ...
terminal String    ID;      // foo, foo_bar, t'is_2_cold_4_me

// Lexing integer literals is trickier than it seems. The Xi language
// specification says that integer literals can range from -9223372036854775808
// (-2^63) to 9223372036854775807 (2^63 - 1). Imagine we try to lex the string
// "-9223372036854775808". What should our lexer do?
//
//   (1) We could lex the string as two tokens: a MINUS token, and
//       a NUM token. The catch is that 9223372036854775808 doesn't fit inside
//       of a Java long, so we can't stick 9223372036854775808 in a NUM token!
//   (2) We could have a regular expression, "-9223372036854775808", that lexes
//       the string as a single NUM token with the value -9223372036854775808.
//       But then, our lexer wouldn't lex "-9223372036854775808"!
//   (3) We could beef up our regular expression from attempt (2) and disregard
//       whitespace between the "-" and the "9223372036854775808". For example,
//       our regular expression could be `- {Whitespace}* 9223372036854775808`.
//       This is also insufficient. Consider the following Xi snippet:
//
//           x: int = -
//                    // random comment
//                    9223372036854775808
//
//       Our regular expression wouldn't lex this correctly.
//   (4) We could beef up our regular expression again accounting for any
//       possible tokens that could occur between '-' and
//       '9223372036854775808'!  Right now that only includes whitespace and
//       single line comments.
//   (5) We could introduce a new token BIG_NUM that is created whenever we lex
//       9223372036854775808 and defer responsibility to the parser.
//
// Solutions (1) - (3) are insufficient. Solutions (4) and (5) have their
// tradeoffs. It's not clear whether (4) is even correct, but (5) complicates
// things quite a bit. We have opted for option (5) because it seems the
// hardest to get wrong.
terminal Long NUM;     // -9223372036854775808, ..., 0, ..., 9223372036854775807
terminal      BIG_NUM; // 9223372036854775808

////////////////////////////////////////////////////////////////////////////////
// Grammar
////////////////////////////////////////////////////////////////////////////////

// types and variables
nonterminal type,
            type_list,
            avar,
            var;

// statements
nonterminal end_stmt,
            full_stmt,
            stmt,
            block,
            full_decl,
            decl,
            var_plus,
            expr_star,
            expr_plus,
            asgn,
            if_body,
            if_stmt,
            while_body,
            while_stmt,
            args_call,
            call;

// functions and procedures
nonterminal args_decl,
            proc_ret,
            func_ret,
            proc_decl,
            func_decl;

// programs 
nonterminal use_def,
            func_def,
            prog;

// expressions
nonterminal expr,
            literal,
            array_literal,
            binop,
            unop;

start with prog;

// actual grammar 

// types and variables
type ::= INT
       | BOOL
       | type LBRACKET RBRACKET

avar ::= ID COLON type
       | UNDERSCORE COLON type

var ::= avar 
      | UNDERSCORE

// statements 

stmt ::= full_decl
       | asgn
       | if_stmt
       | while_stmt
       | call          //both a procedure and function call
       | block

end_stmt ::=            // epsilon
           | SEMICOLON

full_stmt ::= stmt end_stmt

block ::= LBRACE stmt_star RBRACE

full_decl ::= decl 
            | decl EQ expr

decl ::= var
       | LPARENS var_plus RPARENS

asgn ::= ID EQ expr
       | ID LBRACKET expr RBRACKET EQ expr
       | LPARENS var_plus RPARENS EQ LPARENS expr_plus RPARENS

if_body ::= block 
          | full_stmt

if_stmt ::= IF LPARENS expr RPARENS if_body ELSE if_body
          | IF LPARENS expr RPARENS if_body

while_body ::= block 
             | full_stmt

while_stmt ::= WHILE LPARENS expr RPARENS while_body

args_call ::= LPARENS RPARENS 
            | LPARENS expr_plus RPARENS

// both for functions and procedures
call ::= ID args_call

// functions and procedures 
args_decl ::= LPARENS RPARENS
            | LPARENS avar_plus RPARENS

proc_ret ::=                     // epsilon
           | RETURN end_stmt

func_ret ::= RETURN LPARENS expr_plus RPARENS end_stmt

proc_decl ::= ID args_decl LBRACE block proc_ret RBRACE

func_decl ::= ID args_decl COLON type LBRACE block func_ret RBRACE
            | ID args_decl COLON LPARENS type_plus RPARENS LBRACE block func_ret RBRACE

// programs
use_def ::= USE ID end_stmt

func_def ::= func_decl 
           | proc_decl

use_def_star ::=                        //epsilon
               | use_def_star use_def 

func_def_plus ::= func_def
                | func_def_plus func_def

prog ::= use_def_star func_def_plus

// expressions
expr ::= literal
       | expr binop expr
       | unop expr
       | expr LBRACKET expr RBRACKET 
       | LENGTH LPARENS expr RPARENS
       | LPARENS expr RPARENS

literal ::= NUM
          | MINUS BIG_NUM   // ??
          | STRING
          | CHAR
          | TRUE
          | FALSE
          | array_literal

array_literal ::= LPARENS expr_star RPARENS
                | LPARENS expr_plus COMMA RPARENS

binop ::= MINUS 
        | STAR
        | HIGHMULT
        | DIV
        | MOD
        | PLUS
        | LT
        | LTE
        | GTE
        | GT
        | EQEQ
        | NEQ
        | AMP
        | BAR

unop ::= BANG
       | MINUS

// various lists

expr_star ::= 
            | expr_plus

expr_plus ::= expr
            | expr_plus COMMA expr

avar_plus ::= avar
            | avar_plus COMMA avar

var_plus ::= var
           | var_plus COMMA var

type_plus ::= type 
            | type_plus COMMA type

stmt_star ::=                       // epsilon
              | stmt_star full_stmt






















































