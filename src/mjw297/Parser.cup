package mjw297;

import java_cup.runtime.*;
import java.util.ArrayList;
import mjw297.Ast.*;
import java.util.Optional;

parser code {:
	public void syntax_error(Symbol sym){
		report_error(String.format("%d:%d error:Unexpected token %s\n",
					 sym.left, sym.right, SymUtil.symToLiteral(sym)), null);
	}

    // TODO: remove
    Position dummy = new Position(-1, -1);
:}


////////////////////////////////////////////////////////////////////////////////
// Terminals
////////////////////////////////////////////////////////////////////////////////
// Symbols
terminal MINUS,      // -
         BANG,       // !
         STAR,       // *
         HIGHMULT,   // *>>
         DIV,        // /
         MOD,        // %
         PLUS,       // +
         EQ,         // =
         LT,         // <
         LTE,        // <=
         GTE,        // >=
         GT,         // >
         EQEQ,       // ==
         NEQ,        // !=
         AMP,        // &
         BAR,        // |
         SEMICOLON,  // ;
         LPAREN,     // (
         RPAREN,     // )
         LBRACKET,   // [
         RBRACKET,   // ]
         LBRACE,     // {
         RBRACE,     // }
         UNDERSCORE, // _
         COMMA,      // ,
         COLON,      // :
		 UMINUS;	 // -

// Keywords
terminal WHILE,  // while
         IF,     // if
         ELSE,   // else
         RETURN, // return
         INT,    // int
         BOOL,   // bool
         USE,    // use
         LENGTH, // length
         TRUE,   // true
         FALSE;  // false

// Valued Terminals
terminal String    STRING;  // "foo", "bar", ...,
terminal Character CHAR;    // 'a', 'b', ...
terminal String    ID;      // foo, foo_bar, t'is_2_cold_4_me

// Lexing integer literals is trickier than it seems. The Xi language
// specification says that integer literals can range from -9223372036854775808
// (-2^63) to 9223372036854775807 (2^63 - 1). Imagine we try to lex the string
// "-9223372036854775808". What should our lexer do?
//
//   (1) We could lex the string as two tokens: a MINUS token, and
//       a NUM token. The catch is that 9223372036854775808 doesn't fit inside
//       of a Java long, so we can't stick 9223372036854775808 in a NUM token!
//   (2) We could have a regular expression, "-9223372036854775808", that lexes
//       the string as a single NUM token with the value -9223372036854775808.
//       But then, our lexer wouldn't lex "-9223372036854775808"!
//   (3) We could beef up our regular expression from attempt (2) and disregard
//       whitespace between the "-" and the "9223372036854775808". For example,
//       our regular expression could be `- {Whitespace}* 9223372036854775808`.
//       This is also insufficient. Consider the following Xi snippet:
//
//           x: int = -
//                    // random comment
//                    9223372036854775808
//
//       Our regular expression wouldn't lex this correctly.
//   (4) We could beef up our regular expression again accounting for any
//       possible tokens that could occur between '-' and
//       '9223372036854775808'!  Right now that only includes whitespace and
//       single line comments.
//   (5) We could introduce a new token BIG_NUM that is created whenever we lex
//       9223372036854775808 and defer responsibility to the parser.
//
// Solutions (1) - (3) are insufficient. Solutions (4) and (5) have their
// tradeoffs. It's not clear whether (4) is even correct, but (5) complicates
// things quite a bit. We have opted for option (5) because it seems the
// hardest to get wrong.
terminal Long NUM;     // -9223372036854775808, ..., 0, ..., 9223372036854775807
terminal      BIG_NUM; // 9223372036854775808

////////////////////////////////////////////////////////////////////////////////
// Nonterminals
////////////////////////////////////////////////////////////////////////////////

// types and variables
nonterminal Type<Position>
    base_type,
    type;

nonterminal AnnotatedVar<Position>
    avar;

nonterminal Var<Position>
    var;

// statements
nonterminal
    end_stmt;

nonterminal Block<Position>
	block;

nonterminal Stmt<Position>
	if_body,
	while_body;

nonterminal Stmt<Position>
	full_decl,
    full_stmt,
    stmt,
    asgn,
    if_stmt,
    while_stmt;

nonterminal Call<Position>
	call;

nonterminal ArrayList<Expr<Position>>
    args_call;

// functions and procedures
nonterminal ArrayList<AnnotatedVar<Position>>
	args_decl;

nonterminal ArrayList<Expr<Position>>
    func_ret;

nonterminal
    proc_ret;

nonterminal Callable<Position>
    proc_decl,
    func_decl;

// programs
nonterminal Use<Position>
    use_def;

nonterminal Callable<Position>
    func_def;

nonterminal ArrayList<Use<Position>>
    use_def_star;

nonterminal ArrayList<Callable<Position>>
    func_def_plus;

nonterminal Program<Position>
    prog;

nonterminal BinOpCode
	binop;

nonterminal UnOpCode
	unop;

// expressions
nonterminal Expr<Position>
    expr,
    literal;

nonterminal ArrayList<Expr<Position>>
    empty_array_index_star,
    num_array_index_plus,
    array_index_plus;

// various lists
nonterminal ArrayList<Expr<Position>>
    expr_star,
    expr_plus;

nonterminal ArrayList<AnnotatedVar<Position>>
    avar_plus;

nonterminal ArrayList<Var<Position>>
    var_plus;

nonterminal ArrayList<Type<Position>>
    type_plus;

nonterminal ArrayList<Stmt<Position>>
    stmt_star;

////////////////////////////////////////////////////////////////////////////////
// Precedence
////////////////////////////////////////////////////////////////////////////////

precedence nonassoc ID;
precedence nonassoc ELSE;
precedence nonassoc SEMICOLON;
precedence nonassoc EQ;

precedence left BAR;
precedence left AMP;
precedence left EQEQ, NEQ;
precedence left GT, GTE, LT, LTE;
precedence left PLUS, MINUS;
precedence left STAR, DIV, MOD, HIGHMULT;
precedence nonassoc BANG, UMINUS;
precedence left LBRACKET, RBRACKET;

////////////////////////////////////////////////////////////////////////////////
// Grammar
////////////////////////////////////////////////////////////////////////////////

start with prog;

// Types and variables --SH

base_type ::= INT:i
	{: RESULT = Int.of(new Position(ileft, iright)); :}
    | BOOL:b
	{: RESULT = Bool.of(new Position(bleft, bright)); :}
    ;

type ::= base_type:bt
	{: RESULT = bt; :}
    | type:t LBRACKET RBRACKET
	{: RESULT = Array.of(new Position(tleft, tright), t, Optional.empty()); :}
    ;

avar ::= ID:id COLON type:t
    {: Position p = new Position(idleft, idright);
	   RESULT = AnnotatedId.of(p, Id.of(p, id), t); :}
    | UNDERSCORE:u COLON type:t
    {: Position p = new Position(uleft, uright);
	   RESULT = AnnotatedUnderscore.of(p, Underscore.of(p), t); :}
    ;

var ::= avar:av
	{: RESULT = av; :}
    | UNDERSCORE:u
	{: RESULT = Underscore.of(new Position(uleft, uright)); :}
    | ID:id COLON base_type:bt array_index_plus:e_lst
	{: Position p = new Position(idleft, idright);
       Position pArray = new Position(btleft, btright);
	   Expr<Position> first = e_lst.get(0);
	   Type<Position> array_type = Array.of(
	        pArray,
	        bt,
	        first == null ? Optional.empty() : Optional.of(first)
       );
	   for (int i = 1; i < e_lst.size(); i++) {
	       Expr<Position> current = e_lst.get(i);
           array_type = Array.of(
                pArray,
                array_type,
                current == null ? Optional.empty() : Optional.of(current)
           );
	   }
	   RESULT = AnnotatedId.of(
	        p,
	        Id.of(p, id),
	        array_type
       );
    :}
    ;


// Statements --RR

stmt ::= full_decl:f
	{: RESULT = f; :}
    | asgn:a
	{: RESULT = a; :}
    | if_stmt:i
	{: RESULT = i; :}
    | while_stmt:w
	{: RESULT = w; :}
    | call:c
	{: RESULT = c; :}
    ;

end_stmt ::=
    | SEMICOLON
    ;

full_stmt ::= stmt:s end_stmt
	{: RESULT = s; :};

block ::= LBRACE:lb stmt_star:s RBRACE
	{: Position p = new Position(lbleft, lbright); 
	   RESULT = Block.of(p, s, Optional.empty()); :}
	| LBRACE:lb stmt_star:s RETURN expr:e RBRACE
	{: Position p = new Position(lbleft, lbright); 
	   RESULT = Block.of(p, s, Optional.of(e)); :}
	;

full_decl ::= var_plus:v
	{: RESULT = Decl.of(new Position(vleft, vright), v); :}
    | var_plus:v EQ expr:e
	{: RESULT = DeclAsgn.of(new Position(vleft, vright), v, e); :}
    ;

asgn ::= ID:i EQ expr:e
	{: Position p = new Position(ileft, iright);
	   RESULT = Asgn.of(p, Id.of(p,i), e); 
	:}
	| ID:i num_array_index_plus:idx EQ expr:e
	{: Position p = new Position(ileft, iright);
	   Expr<Position> exp = Index.of(p, Id.of(p, i), idx.get(0));
	   for (int j = 1; j < idx.size(); j++) { 
	       exp = Index.of(p, exp, idx.get(j));
	   } 
	   RESULT = Asgn.of(p, exp, e);
	:}
	| call:c num_array_index_plus:idx EQ expr:e
	{: Position p = new Position(cleft, cright);
	   Expr<Position> exp = Index.of(p, c, idx.get(0));
	   for (int i = 1; i < idx.size(); i++) {
	       exp = Index.of(p, exp, idx.get(i));
	   }
	   RESULT = Asgn.of(p, exp, e);
	:} 
	| STRING:s num_array_index_plus:idx EQ expr:e	
	{: Position p = new Position(sleft, sright);
	   Expr<Position> exp = Index.of(p, StringLiteral.of(p, s), idx.get(0));
	   for (int i = 1; i < idx.size(); i++){
	       exp = Index.of(p, exp, idx.get(i));
	   }
	   RESULT = Asgn.of(p, exp, e);
	:}
	;

if_body ::= block:b
	{: RESULT = b; :}
   	| full_stmt:s
	{: RESULT = s; :}
   	;

if_stmt ::= IF:i LPAREN expr:e RPAREN if_body:s1 ELSE if_body:s2
	{: RESULT = IfElse.of(new Position(ileft, iright), e, s1, s2); :}
   	| IF:i LPAREN expr:e RPAREN if_body:s
	{: RESULT = If.of(new Position(ileft, iright), e, s); :}
   	;

while_body ::= block:b
	{: RESULT = b; :}
  	| full_stmt:s
	{: RESULT = s; :}
  	;

while_stmt ::= WHILE:w LPAREN expr:e RPAREN while_body:b
	{: RESULT = While.of(new Position(wleft, wright), e, b); :}
	;

args_call ::= LPAREN RPAREN
	{: RESULT = new ArrayList<>(); :}
    | LPAREN expr_plus:e RPAREN
	{: RESULT = e; :}
    ;

call ::= ID:i args_call:a
	{: Position p = new Position(ileft, iright);
       RESULT = Call.of(p, Id.of(p, i), a); :}
	;


// Functions and procedures --AM

args_decl ::= LPAREN RPAREN
    {: RESULT = new ArrayList<AnnotatedVar<Position>>(); :}
    | LPAREN avar_plus:a RPAREN
    {: RESULT = a; :}
    ;

proc_ret ::=
    {: RESULT = null; :}
    | RETURN end_stmt
    {: RESULT = null; :}
    ;

func_ret ::= RETURN expr_plus:e end_stmt
    {: RESULT = e; :};

proc_decl ::= ID:i args_decl:a LBRACE stmt_star:s proc_ret RBRACE
    {: Position p = new Position(ileft, iright);
       RESULT = Proc.of(p, Id.of(p, i), a, s); :};

func_decl ::= ID:f args_decl:a COLON type_plus:t LBRACE stmt_star:s func_ret:r RBRACE
    {: Position p = new Position(fleft, fright);
       RESULT = Func.of(p, Id.of(p, f), a, t, s, r); :}
    ;


// Programs --AM

use_def ::= USE:u ID:x end_stmt
    {: Position p = new Position(uleft, uright);
       Position pId = new Position(xleft, xright);
       RESULT = Use.of(p, Id.of(pId, x)); :}
	;

func_def ::= func_decl:f
    {: RESULT = f; :}
    | proc_decl:p
    {: RESULT = p; :}
    ;

use_def_star ::=
    {: RESULT = new ArrayList<Use<Position>>(); :}
    | use_def_star:us use_def:u
    {: us.add(u);
	   RESULT = us;
    :}
    ;

func_def_plus ::= func_def:f
    {: ArrayList<Callable<Position>> list = new ArrayList<>();
	   list.add(f);
	   RESULT = list;
	:}
    | func_def_plus:fs func_def:f
    {: fs.add(f);
	   RESULT = fs;
	:}
    ;

prog ::= use_def_star:us func_def_plus:fs
    {: RESULT = Program.of(new Position(usleft, usright), us, fs); :}
	;



// Expressions --SH

expr ::= literal:l
	{: RESULT = l; :}
    | expr:e1 binop:op expr:e2
	{: RESULT = BinOp.of(new Position(e1left, e1right), op, e1, e2); :}
    | unop:op expr:e
	{: RESULT = UnOp.of(new Position(opleft, opright), op, e); :} %prec UMINUS
    | expr:e1 num_array_index_plus:e_lst
	{: Position p = new Position(e1left, e1right);
	   Expr<Position> exp = Index.of(p, e1, e_lst.get(0));   
	   for (int i = 1; i < e_lst.size(); i++) {
	       exp = Index.of(p, exp, e_lst.get(i));
	   }
	   RESULT = exp;
	:}
    | LENGTH:l LPAREN expr:e RPAREN
	{: RESULT = Length.of(new Position(lleft, lright), e); :}
    | LPAREN:l expr:e RPAREN
	{: RESULT = e; :}
    | call:c
	{: RESULT = c; :}
    | ID:id
	{: RESULT = Id.of(new Position(idleft, idright), id); :}
    ;

empty_array_index_star ::=
	{: RESULT = new ArrayList<Expr<Position>>();
	 :}
    | empty_array_index_star:list LBRACKET RBRACKET
	{: list.add(null);
	   RESULT = list;
	:}
    ;

// TODO: expr or NUM?
num_array_index_plus ::= LBRACKET expr:e RBRACKET
	{: ArrayList<Expr<Position>> list = new ArrayList<>();
	   list.add(e);
	   RESULT = list; :}
    | num_array_index_plus:e_lst LBRACKET expr:e RBRACKET
	{: e_lst.add(e);
	   RESULT = e_lst; :}
    ;

array_index_plus ::= LBRACKET RBRACKET empty_array_index_star:emp_lst
	{: emp_lst.add(null);
       RESULT = emp_lst;
	:}
    | num_array_index_plus:e_lst empty_array_index_star:emp_lst
	{: e_lst.addAll(emp_lst);
	   RESULT = e_lst;
	 :}
    ;

literal ::= NUM:n
	{: RESULT = NumLiteral.of(new Position(nleft, nright), n); :}
    | MINUS:m BIG_NUM:n // TODO : ok?
	{: RESULT = NumLiteral.of(new Position(mleft, mright), (Integer) n); :}
    | STRING:s
	{: RESULT = StringLiteral.of(new Position(sleft, sright), s); :}
    | CHAR:c
	{: RESULT = CharLiteral.of(new Position(cleft, cright), c); :}
    | TRUE:b
	{: RESULT = BoolLiteral.of(new Position(bleft, bright), true); :}
    | FALSE:b
	{: RESULT = BoolLiteral.of(new Position(bleft, bright), false); :}
    | LBRACE:l expr_star:e RBRACE
	{: RESULT = ArrayLiteral.of(new Position(lleft, lright), e); :}
    | LBRACE:l expr_plus:e COMMA RBRACE
	{: RESULT = ArrayLiteral.of(new Position(lleft, lright), e); :}
    ;

binop ::= MINUS
	{: RESULT = BinOpCode.MINUS; :}
    | STAR
	{: RESULT = BinOpCode.STAR; :}
    | HIGHMULT
	{: RESULT = BinOpCode.HIGHMULT; :}
    | DIV
	{: RESULT = BinOpCode.DIV; :}
    | MOD
	{: RESULT = BinOpCode.MOD; :}
    | PLUS
	{: RESULT = BinOpCode.PLUS; :}
    | LT
	{: RESULT = BinOpCode.LT; :}
    | LTE
	{: RESULT = BinOpCode.LTE; :}
    | GTE
	{: RESULT = BinOpCode.GTE; :}
    | GT
	{: RESULT = BinOpCode.GT; :}
    | EQEQ
	{: RESULT = BinOpCode.EQEQ; :}
    | NEQ
	{: RESULT = BinOpCode.NEQ; :}
    | AMP
	{: RESULT = BinOpCode.AMP; :}
    | BAR
	{: RESULT = BinOpCode.BAR; :}
    ;

unop ::= BANG
	{: RESULT = UnOpCode.BANG; :}
    | MINUS
	{: RESULT = UnOpCode.UMINUS; :}
    ;


// Various lists --SH

expr_star ::=
	{: RESULT = new ArrayList<Expr<Position>>(); :}
    | expr_plus:e_lst
	{: RESULT = e_lst; :}
    ;

expr_plus ::= expr:e
	{: ArrayList<Expr<Position>> list = new ArrayList<>();
	   list.add(e);
	   RESULT = list; :}
    | expr_plus:e_lst COMMA expr:e
	{: e_lst.add(e);
	   RESULT = e_lst;
	:}
    ;

avar_plus ::= avar:av
	{: ArrayList<AnnotatedVar<Position>> list = new ArrayList<>();
	   list.add(av);
	   RESULT = list; :}
    | avar_plus:a_lst COMMA avar:av
	{: a_lst.add(av);
	   RESULT = a_lst; :}
    ;

var_plus ::= var:v
	{: ArrayList<Var<Position>> list = new ArrayList<>();
	   list.add(v);
	   RESULT = list; :}
    | var_plus:v_lst COMMA var:v
	{: v_lst.add(v);
	   RESULT = v_lst; :}
    ;

type_plus ::= type:t
	{: ArrayList<Type<Position>> list = new ArrayList<>();
	   list.add(t);
	   RESULT = list; :}
    | type_plus:t_lst COMMA type:t
	{: t_lst.add(t);
	   RESULT = t_lst; :}
    ;

stmt_star ::=
	{: RESULT = new ArrayList<Stmt<Position>>(); :}
    | stmt_star:s_lst full_stmt:s
	{: s_lst.add(s);
	   RESULT = s_lst; :}
    ;
