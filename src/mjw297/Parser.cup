package mjw297;

import java_cup.runtime.*;
import java.util.ArrayList;
import mjw297.Ast.*;

////////////////////////////////////////////////////////////////////////////////
// Terminals
////////////////////////////////////////////////////////////////////////////////
// Symbols
terminal MINUS,      // -
         BANG,       // !
         STAR,       // *
         HIGHMULT,   // *>>
         DIV,        // /
         MOD,        // %
         PLUS,       // +
         EQ,         // =
         LT,         // <
         LTE,        // <=
         GTE,        // >=
         GT,         // >
         EQEQ,       // ==
         NEQ,        // !=
         AMP,        // &
         BAR,        // |
         SEMICOLON,  // ;
         LPAREN,     // (
         RPAREN,     // )
         LBRACKET,   // [
         RBRACKET,   // ]
         LBRACE,     // {
         RBRACE,     // }
         UNDERSCORE, // _
         COMMA,      // ,
         COLON,      // :
		 UMINUS;	 // -

// Keywords
terminal WHILE,  // while
         IF,     // if
         ELSE,   // else
         RETURN, // return
         INT,    // int
         BOOL,   // bool
         USE,    // use
         LENGTH, // length
         TRUE,   // true
         FALSE;  // false

// Valued Terminals
terminal String    STRING;  // "foo", "bar", ...,
terminal Character CHAR;    // 'a', 'b', ...
terminal String    ID;      // foo, foo_bar, t'is_2_cold_4_me

// Lexing integer literals is trickier than it seems. The Xi language
// specification says that integer literals can range from -9223372036854775808
// (-2^63) to 9223372036854775807 (2^63 - 1). Imagine we try to lex the string
// "-9223372036854775808". What should our lexer do?
//
//   (1) We could lex the string as two tokens: a MINUS token, and
//       a NUM token. The catch is that 9223372036854775808 doesn't fit inside
//       of a Java long, so we can't stick 9223372036854775808 in a NUM token!
//   (2) We could have a regular expression, "-9223372036854775808", that lexes
//       the string as a single NUM token with the value -9223372036854775808.
//       But then, our lexer wouldn't lex "-9223372036854775808"!
//   (3) We could beef up our regular expression from attempt (2) and disregard
//       whitespace between the "-" and the "9223372036854775808". For example,
//       our regular expression could be `- {Whitespace}* 9223372036854775808`.
//       This is also insufficient. Consider the following Xi snippet:
//
//           x: int = -
//                    // random comment
//                    9223372036854775808
//
//       Our regular expression wouldn't lex this correctly.
//   (4) We could beef up our regular expression again accounting for any
//       possible tokens that could occur between '-' and
//       '9223372036854775808'!  Right now that only includes whitespace and
//       single line comments.
//   (5) We could introduce a new token BIG_NUM that is created whenever we lex
//       9223372036854775808 and defer responsibility to the parser.
//
// Solutions (1) - (3) are insufficient. Solutions (4) and (5) have their
// tradeoffs. It's not clear whether (4) is even correct, but (5) complicates
// things quite a bit. We have opted for option (5) because it seems the
// hardest to get wrong.
terminal Long NUM;     // -9223372036854775808, ..., 0, ..., 9223372036854775807
terminal      BIG_NUM; // 9223372036854775808

////////////////////////////////////////////////////////////////////////////////
// Nonterminals
////////////////////////////////////////////////////////////////////////////////

// types and variables
nonterminal base_type,
            type,
            type_list,
            avar,
            var;

// statements
nonterminal end_stmt,
            full_stmt,
            stmt,
            block,
            full_decl,
            decl,
            asgn,
            if_body,
            if_stmt,
            while_body,
            while_stmt,
            args_call,
            call;

// functions and procedures
nonterminal args_decl,
            proc_ret,
            func_ret,
            proc_decl,
            func_decl;

// programs
nonterminal use_def,
            func_def,
            use_def_star,
			func_def_plus,
			prog;

// expressions
nonterminal expr,
            array_body,
            array,
            empty_array_index_star,
            num_array_index_plus,
            array_index_plus,
            literal,
            binop,
            unop;

// various lists
nonterminal expr_star,
			expr_plus,
			avar_plus,
			var_plus,
			type_plus,
			stmt_star,
            extended_expr,
            paren_expr;

////////////////////////////////////////////////////////////////////////////////
// Precedence
////////////////////////////////////////////////////////////////////////////////

precedence nonassoc ID;
precedence nonassoc ELSE;
precedence nonassoc SEMICOLON;
precedence nonassoc EQ;

precedence left BAR;
precedence left AMP;
precedence left EQEQ, NEQ;
precedence left GT, GTE, LT, LTE;
precedence left PLUS, MINUS;
precedence left STAR, DIV, MOD, HIGHMULT;
precedence nonassoc BANG, UMINUS;
precedence left LBRACKET, RBRACKET;

////////////////////////////////////////////////////////////////////////////////
// Grammar
////////////////////////////////////////////////////////////////////////////////

start with prog;

// Types and variables --SH

base_type ::= INT
    | BOOL
    ;

type ::= base_type
    | type LBRACKET RBRACKET
    ;

avar ::= ID COLON type
    | UNDERSCORE COLON type
    ;

var ::= avar
    | UNDERSCORE
    | ID COLON base_type array_index_plus
    ;


// Statements --RR

stmt ::= full_decl
    | asgn
    | if_stmt
    | while_stmt
    | call
    ;

end_stmt ::=
    | SEMICOLON
    ;

full_stmt ::= stmt end_stmt;

block ::= LBRACE stmt_star RBRACE;

full_decl ::= decl
    | decl EQ extended_expr
    ;

decl ::= var
    | LPAREN var_plus RPAREN
    ;

// TODO: make brackets handle multiple dimensions
asgn ::= ID EQ extended_expr
    | ID num_array_index_plus EQ extended_expr
    ;

if_body ::= block
   | full_stmt
   ;

if_stmt ::= IF LPAREN expr RPAREN if_body ELSE if_body
   | IF LPAREN expr RPAREN if_body
   ;

while_body ::= block
  | full_stmt
  ;

while_stmt ::= WHILE LPAREN expr RPAREN while_body;

args_call ::= LPAREN RPAREN
    | LPAREN expr_plus RPAREN
    ;

call ::= ID args_call;


// Functions and procedures --AM

args_decl ::= LPAREN RPAREN                {: RESULT = new ArrayList<Expr>(); :}
    | LPAREN avar_plus:a RPAREN            {: RESULT = a; :}
    ;

proc_ret ::=                               {: RESULT = null; :}
    | RETURN end_stmt                      {: RESULT = null; :}
    ;

func_ret ::= RETURN LPAREN expr_plus:e RPAREN end_stmt
                                           {: RESULT = e; :};

proc_decl ::= ID:p args_decl:a LBRACE stmt_star:s proc_ret RBRACE
                                           {: RESULT = new Proc(new Id(p), a, s); :};

func_decl ::= ID:f args_decl:a COLON type:t LBRACE stmt_star:s func_ret:r RBRACE
                                           {: RESULT = new Func(new Id(f), a, t, s, r); :}
    | ID:f args_decl:a COLON LPAREN type_plus:t RPAREN LBRACE stmt_star:s func_ret:r RBRACE
                                           {: RESULT = new Func(new Id(f), a, t, s, r); :}
    ;


// Programs --AM

use_def ::= USE ID:x end_stmt              {: RESULT = new Use(new Id(x)); :};

func_def ::= func_decl:f                   {: RESULT = f; :}
    | proc_decl:p                          {: RESULT = p; :}
    ;

use_def_star ::=                           {: RESULT = new ArrayList<Use>(); :}
    | use_def_star:us use_def:u            {: RESULT = us.add(u); :}
    ;

func_def_plus ::= func_def:f               {: RESULT = (new ArrayList<Callable>()).add(f); :}
    | func_def_plus:fs func_def:f          {: RESULT = fs.add(f); :}
    ;

prog ::= use_def_star:us func_def_plus:fs  {: RESULT = new Program(us, fs); :};


// Expressions --SH

expr ::= literal
    | expr binop expr
    | unop expr %prec UMINUS
    | expr num_array_index_plus
    | LENGTH LPAREN expr RPAREN
    | LPAREN expr RPAREN
    | call
    | ID
    ;

extended_expr ::= paren_expr
    | array
    | extended_expr binop extended_expr
    ;

paren_expr ::= literal
    | paren_expr binop paren_expr
    | unop paren_expr %prec UMINUS
    | paren_expr num_array_index_plus
    | LENGTH LPAREN paren_expr RPAREN
    | LPAREN paren_expr RPAREN
    | call
    | ID
    ;

array_body ::= paren_expr COMMA paren_expr
    | array
    | array_body COMMA paren_expr
    | array_body COMMA array
    ;

array ::= LPAREN paren_expr COMMA RPAREN
    | LPAREN array_body RPAREN
    | LPAREN array_body COMMA RPAREN
    ;

empty_array_index_star ::=
    | empty_array_index_star LBRACKET RBRACKET
    ;

// TODO: expr or NUM?
num_array_index_plus ::= LBRACKET expr RBRACKET
    | num_array_index_plus LBRACKET expr RBRACKET
    ;

array_index_plus ::= LBRACKET RBRACKET
    | num_array_index_plus empty_array_index_star
    ;

literal ::= NUM
    | MINUS BIG_NUM // TODO : ok?
    | STRING
    | CHAR
    | TRUE
    | FALSE
    ;

binop ::= MINUS
    | STAR
    | HIGHMULT
    | DIV
    | MOD
    | PLUS
    | LT
    | LTE
    | GTE
    | GT
    | EQEQ
    | NEQ
    | AMP
    | BAR
    ;

unop ::= BANG
    | MINUS
    ;


// Various lists --SH

expr_star ::=
    | expr_plus
    ;

expr_plus ::= expr
    | expr_plus COMMA expr
    ;

avar_plus ::= avar
    | avar_plus COMMA avar
    ;

var_plus ::= var
    | var_plus COMMA var
    ;

type_plus ::= type
    | type_plus COMMA type
    ;

stmt_star ::=
    | stmt_star full_stmt
    ;
