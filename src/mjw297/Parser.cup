import java_cup.runtime.*;

////////////////////////////////////////////////////////////////////////////////
// Terminals
////////////////////////////////////////////////////////////////////////////////
// Symbols
terminal MINUS,      // -
         BANG,       // !
         STAR,       // *
         HIGHMULT,   // *>>
         DIV,        // /
         MOD,        // %
         PLUS,       // +
         EQ,         // =
         LT,         // <
         LTE,        // <=
         GTE,        // >=
         GT,         // >
         EQEQ,       // ==
         NEQ,        // !=
         AMP,        // &
         BAR,        // |
         SEMICOLON,  // ;
         LPAREN,     // (
         RPAREN,     // )
         LBRACKET,   // [
         RBRACKET,   // ]
         LBRACE,     // {
         RBRACE,     // }
         UNDERSCORE, // _
         COMMA,      // ,
         COLON,      // :
		 UMINUS;	 // -

// Keywords
terminal WHILE,  // while
         IF,     // if
         ELSE,   // else
         RETURN, // return
         INT,    // int
         BOOL,   // bool
         USE,    // use
         LENGTH, // length
         TRUE,   // true
         FALSE;  // false

// Valued Terminals
terminal String    STRING;  // "foo", "bar", ...,
terminal Character CHAR;    // 'a', 'b', ...
terminal String    ID;      // foo, foo_bar, t'is_2_cold_4_me

// Lexing integer literals is trickier than it seems. The Xi language
// specification says that integer literals can range from -9223372036854775808
// (-2^63) to 9223372036854775807 (2^63 - 1). Imagine we try to lex the string
// "-9223372036854775808". What should our lexer do?
//
//   (1) We could lex the string as two tokens: a MINUS token, and
//       a NUM token. The catch is that 9223372036854775808 doesn't fit inside
//       of a Java long, so we can't stick 9223372036854775808 in a NUM token!
//   (2) We could have a regular expression, "-9223372036854775808", that lexes
//       the string as a single NUM token with the value -9223372036854775808.
//       But then, our lexer wouldn't lex "-9223372036854775808"!
//   (3) We could beef up our regular expression from attempt (2) and disregard
//       whitespace between the "-" and the "9223372036854775808". For example,
//       our regular expression could be `- {Whitespace}* 9223372036854775808`.
//       This is also insufficient. Consider the following Xi snippet:
//
//           x: int = -
//                    // random comment
//                    9223372036854775808
//
//       Our regular expression wouldn't lex this correctly.
//   (4) We could beef up our regular expression again accounting for any
//       possible tokens that could occur between '-' and
//       '9223372036854775808'!  Right now that only includes whitespace and
//       single line comments.
//   (5) We could introduce a new token BIG_NUM that is created whenever we lex
//       9223372036854775808 and defer responsibility to the parser.
//
// Solutions (1) - (3) are insufficient. Solutions (4) and (5) have their
// tradeoffs. It's not clear whether (4) is even correct, but (5) complicates
// things quite a bit. We have opted for option (5) because it seems the
// hardest to get wrong.
terminal Long NUM;     // -9223372036854775808, ..., 0, ..., 9223372036854775807
terminal      BIG_NUM; // 9223372036854775808

////////////////////////////////////////////////////////////////////////////////
// Nonterminals
////////////////////////////////////////////////////////////////////////////////

// types and variables
nonterminal type,
            type_list,
            avar,
            var;

// statements
nonterminal end_stmt,
            full_stmt,
            stmt,
            block,
            full_decl,
            decl,
            asgn,
            if_body,
            if_stmt,
            while_body,
            while_stmt,
            args_call,
            call;

// functions and procedures
nonterminal args_decl,
            proc_ret,
            func_ret,
            proc_decl,
            func_decl;

// programs
nonterminal use_def,
            func_def,
            use_def_star,
			func_def_plus,
			prog;

// expressions
nonterminal expr,
            literal,
            binop,
            unop;

// various lists
nonterminal expr_star,
			expr_plus,
			avar_plus,
			var_plus,
			type_plus,
			stmt_star,
            extended_expr,
            extended_expr_star,
            extended_expr_plus;

////////////////////////////////////////////////////////////////////////////////
// Precedence
////////////////////////////////////////////////////////////////////////////////

precedence nonassoc ELSE;
precedence nonassoc SEMICOLON;
precedence nonassoc EQ;

precedence left BAR;
precedence left AMP;
precedence left EQEQ, NEQ;
precedence left GT, GTE, LT, LTE;
precedence left PLUS, MINUS;
precedence left STAR, DIV, MOD, HIGHMULT;
precedence nonassoc BANG, UMINUS;
precedence left LBRACKET, RBRACKET;

////////////////////////////////////////////////////////////////////////////////
// Grammar
////////////////////////////////////////////////////////////////////////////////

start with prog;

 // types and variables
 type ::= INT
        | BOOL
        | type LBRACKET RBRACKET
        ;

 avar ::= ID COLON type
        | UNDERSCORE COLON type
        ;

 var ::= avar
       | UNDERSCORE
       ;

 // statements

 stmt ::= full_decl
        | asgn
        | if_stmt
        | while_stmt
        | call          //both a procedure and function call
        ;

 end_stmt ::=            // epsilon
            | SEMICOLON
            ;

 full_stmt ::= stmt end_stmt;

 block ::= LBRACE stmt_star RBRACE;

 full_decl ::= decl
             | decl EQ extended_expr
             ;

 decl ::= var
        | LPAREN var_plus RPAREN
        ;

 // TODO: make brackets handle multiple dimensions
 asgn ::= ID EQ expr
        | ID LBRACKET expr RBRACKET EQ expr
        ;

 if_body ::= block
           | full_stmt
           ;

 if_stmt ::= IF LPAREN expr RPAREN if_body ELSE if_body
           | IF LPAREN expr RPAREN if_body
           ;

 while_body ::= block
              | full_stmt
              ;

 while_stmt ::= WHILE LPAREN expr RPAREN while_body;

 args_call ::= LPAREN RPAREN
             | LPAREN expr_plus RPAREN
             ;

 // both for functions and procedures
 call ::= ID args_call;

 // functions and procedures
 args_decl ::= LPAREN RPAREN
             | LPAREN avar_plus RPAREN
             ;

 proc_ret ::=                     // epsilon
            | RETURN end_stmt
            ;

 func_ret ::= RETURN LPAREN expr_plus RPAREN end_stmt;

 proc_decl ::= ID args_decl LBRACE stmt_star proc_ret RBRACE;

 func_decl ::= ID args_decl COLON type LBRACE stmt_star func_ret RBRACE
             | ID args_decl COLON LPAREN type_plus RPAREN LBRACE stmt_star func_ret RBRACE
             ;

 // programs
 use_def ::= USE ID end_stmt;

 func_def ::= func_decl
            | proc_decl
            ;

 use_def_star ::=                        //epsilon
                | use_def_star use_def
                ;

 func_def_plus ::= func_def
                 | func_def_plus func_def
                 ;

 prog ::= use_def_star func_def_plus;

 // expressions
 expr ::= literal
        | expr binop expr
        | unop expr %prec UMINUS
        | expr LBRACKET expr RBRACKET
        | LENGTH LPAREN expr RPAREN
		| LPAREN expr RPAREN
		| call
        ;
        
 extended_expr ::= literal
        	  | extended_expr binop extended_expr
        	  | unop expr %prec UMINUS
        	  | expr LBRACKET expr RBRACKET
        	  | LENGTH LPAREN expr RPAREN
			  | LPAREN extended_expr_star RPAREN
			  | LPAREN extended_expr_plus COMMA RPAREN
			  | call
        	  ;
              
 literal ::= NUM
           | MINUS BIG_NUM   // ??
           | STRING
           | CHAR
           | TRUE
           | FALSE
           ;

 binop ::= MINUS
         | STAR
         | HIGHMULT
         | DIV
         | MOD
         | PLUS
         | LT
         | LTE
         | GTE
         | GT
         | EQEQ
         | NEQ
         | AMP
         | BAR
         ;

 unop ::= BANG
        | MINUS
        ;

 // various lists

 expr_star ::=
             | expr_plus
             ;

 expr_plus ::= expr
             | expr_plus COMMA expr
             ;

 avar_plus ::= avar
             | avar_plus COMMA avar
             ;

 var_plus ::= var
            | var_plus COMMA var
            ;

 type_plus ::= type
             | type_plus COMMA type
             ;

 stmt_star ::=                       // epsilon
               | stmt_star full_stmt
               ;

 extended_expr_star ::= %prec STAR
                      | extended_expr_star extended_expr %prec BAR
                      ;

 extended_expr_plus ::= extended_expr
                      | extended_expr_plus COMMA extended_expr
                      ;
