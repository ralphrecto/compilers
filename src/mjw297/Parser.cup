import java_cup.runtime.*;

////////////////////////////////////////////////////////////////////////////////
// Terminals
////////////////////////////////////////////////////////////////////////////////
// Symbols
terminal MINUS,      // -
         BANG,       // !
         STAR,       // *
         HIGHMULT,   // *>>
         DIV,        // /
         MOD,        // %
         PLUS,       // +
         EQ,         // =
         LT,         // <
         LTE,        // <=
         GTE,        // >=
         GT,         // >
         EQEQ,       // ==
         NEQ,        // !=
         AMP,        // &
         BAR,        // |
         SEMICOLON,  // ;
         LPAREN,     // (
         RPAREN,     // )
         LBRACKET,   // [
         RBRACKET,   // ]
         LBRACE,     // {
         RBRACE,     // }
         UNDERSCORE, // _
         COMMA,      // ,
         COLON,      // :
		 UMINUS;	 // -

// Keywords
terminal WHILE,  // while
         IF,     // if
         ELSE,   // else
         RETURN, // return
         INT,    // int
         BOOL,   // bool
         USE,    // use
         LENGTH, // length
         TRUE,   // true
         FALSE;  // false

// Valued Terminals
terminal String    STRING;  // "foo", "bar", ...,
terminal Character CHAR;    // 'a', 'b', ...
terminal String    ID;      // foo, foo_bar, t'is_2_cold_4_me

// Lexing integer literals is trickier than it seems. The Xi language
// specification says that integer literals can range from -9223372036854775808
// (-2^63) to 9223372036854775807 (2^63 - 1). Imagine we try to lex the string
// "-9223372036854775808". What should our lexer do?
//
//   (1) We could lex the string as two tokens: a MINUS token, and
//       a NUM token. The catch is that 9223372036854775808 doesn't fit inside
//       of a Java long, so we can't stick 9223372036854775808 in a NUM token!
//   (2) We could have a regular expression, "-9223372036854775808", that lexes
//       the string as a single NUM token with the value -9223372036854775808.
//       But then, our lexer wouldn't lex "-9223372036854775808"!
//   (3) We could beef up our regular expression from attempt (2) and disregard
//       whitespace between the "-" and the "9223372036854775808". For example,
//       our regular expression could be `- {Whitespace}* 9223372036854775808`.
//       This is also insufficient. Consider the following Xi snippet:
//
//           x: int = -
//                    // random comment
//                    9223372036854775808
//
//       Our regular expression wouldn't lex this correctly.
//   (4) We could beef up our regular expression again accounting for any
//       possible tokens that could occur between '-' and
//       '9223372036854775808'!  Right now that only includes whitespace and
//       single line comments.
//   (5) We could introduce a new token BIG_NUM that is created whenever we lex
//       9223372036854775808 and defer responsibility to the parser.
//
// Solutions (1) - (3) are insufficient. Solutions (4) and (5) have their
// tradeoffs. It's not clear whether (4) is even correct, but (5) complicates
// things quite a bit. We have opted for option (5) because it seems the
// hardest to get wrong.
terminal Long NUM;     // -9223372036854775808, ..., 0, ..., 9223372036854775807
terminal      BIG_NUM; // 9223372036854775808

////////////////////////////////////////////////////////////////////////////////
// Nonterminals
////////////////////////////////////////////////////////////////////////////////

// types and variables
nonterminal base_type,
            type,
            type_list,
            avar,
            var;

// statements
nonterminal end_stmt,
            full_stmt,
            stmt,
            block,
            full_decl,
            decl,
            asgn,
            if_body,
            if_stmt,
            while_body,
            while_stmt,
            args_call,
            call;

// functions and procedures
nonterminal args_decl,
            proc_ret,
            func_ret,
            proc_decl,
            func_decl;

// programs
nonterminal use_def,
            func_def,
            use_def_star,
			func_def_plus,
			prog;

// expressions
nonterminal expr,
            array_body,
            array,
            empty_array_index_star,
            num_array_index_plus,
            array_index_plus,
            literal,
            binop,
            unop;

// various lists
nonterminal expr_star,
			expr_plus,
			avar_plus,
			var_plus,
			type_plus,
			stmt_star,
            extended_expr,
            paren_expr;

////////////////////////////////////////////////////////////////////////////////
// Precedence
////////////////////////////////////////////////////////////////////////////////

precedence nonassoc ID;
precedence nonassoc ELSE;
precedence nonassoc SEMICOLON;
precedence nonassoc EQ;

precedence left BAR;
precedence left AMP;
precedence left EQEQ, NEQ;
precedence left GT, GTE, LT, LTE;
precedence left PLUS, MINUS;
precedence left STAR, DIV, MOD, HIGHMULT;
precedence nonassoc BANG, UMINUS;
precedence left LBRACKET, RBRACKET;

////////////////////////////////////////////////////////////////////////////////
// Grammar
////////////////////////////////////////////////////////////////////////////////

start with prog;

// Types and variables --SH

base_type ::= INT
    | BOOL
    ;

type ::= base_type
    | type LBRACKET RBRACKET
    ;

avar ::= ID COLON type
    | UNDERSCORE COLON type
    ;

var ::= avar
    | UNDERSCORE
    | ID COLON base_type array_index_plus
    ;


// Statements --RR

stmt ::= full_decl:f                                             {: RESULT = f; :}
    | asgn:a                                                     {: RESULT = a; :}
    | if_stmt:i                                                  {: RESULT = i; :}
    | while_stmt:w                                               {: RESULT = w; :}
    | call:c                                                     {: RESULT = c; :}
    ;

end_stmt ::=
    | SEMICOLON
    ;

full_stmt ::= stmt:s end_stmt;                                   {: RESULT = s; :}

block ::= LBRACE stmt_star:s RBRACE;                             {: RESULT = s; :}

full_decl ::= decl:d                                             {: RESULT = d; :}
    | decl:d EQ extended_expr:e                                  {: RESULT = new DeclAsgn(d.vs, e); :}
    ;

decl ::= var:v                                                   {: RESULT = new Ast.Decl(new ArrayList<>(v)); :}
    | LPAREN var_plus:v RPAREN                                   {: RESULT = new Ast.Decl(v); :}
    ;

asgn ::= ID:i EQ extended_expr:e                                 {: RESULT = new Ast.Asgn(i, e); :}
    | ID:i num_array_index_plus:b EQ extended_expr:e             {: RESULT = new Ast.AsgnArrayIndex(i, b, e); :}
    ;

if_body ::= block:b                                              {: RESULT = b; :}
   | full_stmt:s                                                 {: RESULT = s; :}
   ;

if_stmt ::=
   IF LPAREN expr:e RPAREN if_body:s1 ELSE if_body:s2            {: RESULT = new Ast.IfElse(e, s1, s2); :}
   | IF LPAREN expr:e RPAREN if_body:s                           {: RESULT = new Ast.If(e, s); :}
   ;

while_body ::= block:b                                           {: RESULT = b; :}
  | full_stmt:s                                                  {: RESULT = s; :}
  ;

while_stmt ::= WHILE LPAREN expr:e RPAREN while_body:b;          {: RESULT = new Ast.While(e, b); :}

args_call ::= LPAREN RPAREN                                      {: RESULT = new ArrayList<>(); :}
    | LPAREN expr_plus:e RPAREN                                  {: RESULT = e; :}
    ;

call ::= ID:i args_call:a;                                       {: RESULT = new Ast.Call(i, a); :}


// Functions and procedures --AM

args_decl ::= LPAREN RPAREN
    | LPAREN avar_plus RPAREN
    ;

proc_ret ::=
    | RETURN end_stmt
    ;

func_ret ::= RETURN LPAREN expr_plus RPAREN end_stmt;

proc_decl ::= ID args_decl LBRACE stmt_star proc_ret RBRACE;

func_decl ::= ID args_decl COLON type LBRACE stmt_star func_ret RBRACE
    | ID args_decl COLON LPAREN type_plus RPAREN LBRACE stmt_star func_ret RBRACE
    ;


// Programs --AM

use_def ::= USE ID end_stmt;

func_def ::= func_decl
    | proc_decl
    ;

use_def_star ::=
    | use_def_star use_def
    ;

func_def_plus ::= func_def
    | func_def_plus func_def
    ;

prog ::= use_def_star func_def_plus;


// Expressions --SH

expr ::= literal
    | expr binop expr
    | unop expr %prec UMINUS
    | expr num_array_index_plus
    | LENGTH LPAREN expr RPAREN
    | LPAREN expr RPAREN
    | call
    | ID
    ;

extended_expr ::= paren_expr
    | array
    | extended_expr binop extended_expr
    ;

paren_expr ::= literal
    | paren_expr binop paren_expr
    | unop paren_expr %prec UMINUS
    | paren_expr num_array_index_plus
    | LENGTH LPAREN paren_expr RPAREN
    | LPAREN paren_expr RPAREN
    | call
    | ID
    ;

array_body ::= paren_expr COMMA paren_expr
    | array
    | array_body COMMA paren_expr
    | array_body COMMA array
    ;

array ::= LPAREN paren_expr COMMA RPAREN
    | LPAREN array_body RPAREN
    | LPAREN array_body COMMA RPAREN
    ;

empty_array_index_star ::=
    | empty_array_index_star LBRACKET RBRACKET
    ;

// TODO: expr or NUM?
num_array_index_plus ::= LBRACKET expr RBRACKET
    | num_array_index_plus LBRACKET expr RBRACKET
    ;

array_index_plus ::= LBRACKET RBRACKET
    | num_array_index_plus empty_array_index_star
    ;

literal ::= NUM
    | MINUS BIG_NUM // TODO : ok?
    | STRING
    | CHAR
    | TRUE
    | FALSE
    ;

binop ::= MINUS
    | STAR
    | HIGHMULT
    | DIV
    | MOD
    | PLUS
    | LT
    | LTE
    | GTE
    | GT
    | EQEQ
    | NEQ
    | AMP
    | BAR
    ;

unop ::= BANG
    | MINUS
    ;


// Various lists --SH

expr_star ::=
    | expr_plus
    ;

expr_plus ::= expr
    | expr_plus COMMA expr
    ;

avar_plus ::= avar
    | avar_plus COMMA avar
    ;

var_plus ::= var
    | var_plus COMMA var
    ;

type_plus ::= type
    | type_plus COMMA type
    ;

stmt_star ::=
    | stmt_star full_stmt
    ;
